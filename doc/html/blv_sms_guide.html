<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BlueViaAndroidSDK: SMS API guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BlueViaAndroidSDK&#160;<span id="projectnumber">1.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('blv_sms_guide.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<h1>SMS API guide </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="sms_abstract_sec"></a>
Abstract</h2>
<p>The Bluevia SMS API is a set of functions which allows users to send and receive SMS messages (both text and binary SMS messages) and to request the status of those previously sent SMS messages. This guide represents a practical introduction to developing applications in which the user wants to provide the Bluevia SMS functionality.</p>
<h2><a class="anchor" id="blv_sms_api_sending_sms_messages_sec"></a>
Bluevia SMS API: Sending SMS messages</h2>
<p>The Bluevia SMS API is a set of functions which allows users to send and receive SMS messages (both text and binary SMS messages) and to request the status of those previously sent SMS messages. This guide represents a practical introduction to developing applications in which the user wants to provide the Bluevia SMS functionality.</p>
<h3><a class="anchor" id="sms_client_basics_sec"></a>
SMS Client Basics</h3>
<p>A SMS client represents the client side in a classic client-server schema. This object wraps up the underlying REST client side functionality needed to perform requests against a REST server. Moreover the SMS client provides a set of mock working modes useful to test its functionality even without connectivity or a real server.</p>
<p>Any Bluevia client perform requests and receive responses in a secure mode. Clients are authorized following the OAuth protocol. This security protocol enables users to grant third-party access to their resources without sharing their passwords. So clients store the authorization data -called security credentials- to grant access the server. Following sections describe what security credentials we are talking about.</p>
<h3><a class="anchor" id="creating_a_sms_client_sec"></a>
Creating a SMS Client</h3>
<p>The first step in using the SMS client is to create a SmsClient object. As we mentioned earlier this object could have two different working modes: i) as a client which sends requests to a real server, or ii) as a client which sends request and receives responses to/from a mock server. If the user wants to test or to run his application by using a mock client he also can decide how the server will work.</p>
<h4><a class="anchor" id="smsclient_features_working_modes_sec"></a>
SmsClient features: working modes</h4>
<p>When you create the client, you can specify various working modes: </p>
<ul>
<li>
<p class="startli">AbstractRestClient.Mode.HTTP <br/>
The client works against a Live Bluevia server.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">AbstractRestClient.Mode.HTTP_SANDBOX <br/>
The client works against a Sandbox Bluevia server.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">AbstractRestClient.Mode.TEST_OK <br/>
The client works against a mock Bluevia server which always serves properly any request.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">AbstractRestClient.Mode.TEST_UNAUTHORIZED <br/>
The client works against a mock Bluevia server which always responds with an BlueviaClientException informing the user is not authorized to perform that request.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">AbstractRestClient.Mode.TEST_ERROR_IOEXCEPTION <br/>
The client works against a mock Bluevia server which always responds with an BlueviaClientException informing the user is unable to connect the server due to an in/out exception.</p>
<p class="endli"></p>
</li>
<li>
AbstractRestClient.Mode.TEST_ERROR_HTTPEXCEPTION <br/>
The client works against a mock Bluevia server which always responds with a BlueviaClientException informing the user is unable to connect the server due a http exception. </li>
</ul>
<h4><a class="anchor" id="smsclient_features_security_credentials"></a>
SmsClient features: security credentials</h4>
<p>BlueVia uses OAuth as its authentication mechanism which enables websites and applications to access the BlueVia API's without end users disclosing their personal credentials. In order to grant access to the server any client has to be created passing the security credential as parameter in its constructor. These security credentials are managed internally and added as a HTTP header in every request sent to the server. Such Oauth security credentials are: </p>
<ul>
<li>
<p class="startli"><b>Consumer key</b> <br/>
The string identifying the application- you obtained when you registered your application within the provisioning portal.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Consumer Secret</b> <br/>
A secret -a string- used by the consumer to establish ownership of the consumer key.</p>
<p class="endli"></p>
</li>
<li>
<b>Access token</b> <br/>
The token -OAuth access token- used by the client for granting access permissions to the server </li>
</ul>
<h4><a class="anchor" id="smsclient_features_recipients_addresses"></a>
SmsClient features: recipients</h4>
<p>A key issue on this client is how to specify the recipients for every SMS message. Recipients use the object called UserId. This class represents the user identification. It may be used to identify the user on requests.</p>
<p>How to specify recipients addresses: </p>
<ul>
<li>
<p class="startli">Recipient: The recipient of the SMS may be identified by a phone number. The user must indicate a phone number as 'userIdValue' value which is a maximum of 15 digits following the E164 format and a UserId.PHONE_NUMBER value for the 'type' parameter.</p>
<div class="fragment"><pre class="fragment"> UserId userId(UserId.PHONE_NUMBER, <span class="stringliteral">&quot;0034913374214&quot;</span>);
</pre></div>  </li>
</ul>
<h4><a class="anchor" id="smsclient_features_freeing_resources_sec"></a>
SmsClient features: freeing resources</h4>
<p>It is very important to free the resources that the client instantiates to work. To do this call the close method after finishing using the client:</p>
<div class="fragment"><pre class="fragment">smsClient.close();
</pre></div><h4><a class="anchor" id="smsclient_features_code_examples_sec"></a>
SmsClient features: code examples</h4>
<p>Find below an example about how to create a SmsClient taking into account all information previously given. This snippet shows how to access a Bluevia server using OAuth security credentials</p>
<div class="fragment"><pre class="fragment"><span class="comment">// The token - OAuth access token.</span>
Token accessToken = <span class="keyword">new</span> Token(<span class="stringliteral">&quot;oauth_token&quot;</span>, <span class="stringliteral">&quot;oauth_token_secret&quot;</span>);

<span class="comment">// AbstractRestClient.Mode.HTTP indicating the client works against a real Bluevia server.</span>
<span class="keywordflow">try</span> {
        BlueviaSmsClient smsClient = <span class="keyword">new</span> BlueviaSmsClient(getApplicationContext(), AbstractRestClient.Mode.HTTP, <span class="stringliteral">&quot;consumer_key&quot;</span>, <span class="stringliteral">&quot;consumer_secret&quot;</span>, accessToken);
} <span class="keywordflow">catch</span> (BlueviaClientException e){
        Log.e(TAG, e.getMessage());
}
</pre></div><h3><a class="anchor" id="creating_sms_messages_sec"></a>
Creating SMS messages</h3>
<p>This API allows users to create both SMS text messages and SMS binary messages. Find below all information needed to create these objects and send them later.</p>
<h4><a class="anchor" id="creating_sms_messages_sms_text_messages_sec"></a>
Creating SMS messages: SMS text messages</h4>
<p>User creates new SMS text messages by using the SmsMessage class. This class represents a SMS text message object which an user send to one or several recipients.</p>
<p>The SmsMessage class has a base class called Sms so it inherits all functionality found in the parent class.</p>
<h4><a class="anchor" id="sms_text_messages_sms_message_features_sec"></a>
SMS text messages: features</h4>
<p>These are the features provide by the SmsMessage object: </p>
<ul>
<li>
An user creates a SmsMessage object by specifying a single recipients and a message text and a source identification from this SmsMessage is sent. A different approach is to create a SmsMessage object by specifying a list of recipients instead a single recipients. </li>
<li>
Once the user create a SmsMessage it is possible to add new recipients. </li>
<li>
Recipients, source, message text, and other optional parameters could be retrieved by using the corresponding access functions. </li>
</ul>
<p>For a more detailed description see the <a class="el" href="api_reference.html">API Reference</a>.</p>
<h4><a class="anchor" id="sms_text_messages_code_example_sec"></a>
SMS text messages: code examples</h4>
<p>Find below an example about how to create a SmsMessage object taking into account all information previously given.</p>
<div class="fragment"><pre class="fragment">SmsMessage sms = <span class="keyword">new</span> SmsMessage();
sms.setMessage(<span class="stringliteral">&quot;This is the text to be sent&quot;</span>);
sms.addAddress(<span class="keyword">new</span> UserId(Type.PHONE_NUMBER,<span class="stringliteral">&quot;600010101&quot;</span>));
</pre></div><h3><a class="anchor" id="sms_binary_messages_sec"></a>
SMS binary messages</h3>
<h4><a class="anchor" id="creating_sms_messages_sms_binary_messages_sec"></a>
Creating SMS messages: SMS binary messages</h4>
<p>User creates new SMS binary messages by using the BinarySms class. This class represents a SMS binary message object which an user send to one or several recipients.</p>
<p>The BinarySms class has a base class called SmsMessage so it inherits all functionality found in the parent class.</p>
<h4><a class="anchor" id="sms_binary_messages_sms_message_features_sec"></a>
SMS binary messages: features</h4>
<p>These are the features provide by the BinarySms object: </p>
<ul>
<li>
An user creates a BinarySms object by specifying a single recipients and a payload and a source identification and a pair of ports -source and destination- and some flags parameters. A different approach is to create a BinarySms object by specifying a list of recipients instead a single recipients. </li>
<li>
Once the user create a BinarySms it is possible to add new recipients. </li>
<li>
All members such as recipients and source and ports could be retrieved by using the corresponding access functions. </li>
</ul>
<h4><a class="anchor" id="sms_binary_messages_code_example_sec"></a>
SMS binary messages: code examples</h4>
<p>Find below an example about how to create a BinarySms object taking into account all information previously given.</p>
<div class="fragment"><pre class="fragment">BinarySms binarySms = <span class="keyword">new</span> BinarySms();
String payload = <span class="stringliteral">&quot;prueba&quot;</span>;
<span class="keywordflow">try</span> {
        sms.setPayload(payload.getBytes());
} <span class="keywordflow">catch</span> (BlueviaClientException e) {
        Log.e(TAG, e.getMessage());
}
binarySms.addAddress(<span class="keyword">new</span> UserId(Type.PHONE_NUMBER,<span class="stringliteral">&quot;600010101&quot;</span>));
binarySms.setSourcePort(1000);
binarySms.setDestinationPort(1001);
binarySms.setEsmClass(0);
binarySms.setDataCoding(1);
</pre></div><h3><a class="anchor" id="sending_smsmessages_sec"></a>
Sending SMS messages</h3>
<p>The SmsClient object has one function for sending SMS messages. This function allows an user to send directly a SmsMessage object previously created.</p>
<p>Take a look at this function: </p>
<ul>
<li>
<div class="fragment"><pre class="fragment"> String sendSms(SmsMessage sms) <span class="keywordflow">throws</span> BlueviaClientException 
</pre></div> It sends directly a SmsMessage previously created. This function returns the SMS Id which indentifies that sending operation. This identification is useful to retrieve the delivery status of that SMS message. </li>
</ul>
<p>For a more detailed description see the <a class="el" href="api_reference.html">API Reference</a>.</p>
<h3><a class="anchor" id="requesting_the_status_of_a_previously_sent_SMS_messages"></a>
Requesting the status of a previously sent SMS messages</h3>
<p>Once the SMS message is sent successfully the user may want to know the delivery status of that SMS message. The SmsClient allows an user to determine if the SMS message reaches the destination or not. For this matter we use the GetSmsDeliveryStatus function. Just pass the SMS Id -returned by the sendSms function- and retrieve the delivery status of that message, so easy!.</p>
<p>Take a look at this function: </p>
<ul>
<li>
<div class="fragment"><pre class="fragment"> ArrayList&lt;SmsDeliveryStatus&gt; getDeliveryStatus(String smsId); 
</pre></div><p> It obtains the delivery status of a previously sent SMS message.</p>
<p class="endli">Possible delivery statuses are: </p>
<ul>
<li>
DeliveredToNetwork. </li>
<li>
DeliveryUncertain. </li>
<li>
DeliveryImpossible. </li>
<li>
MessageWaiting. </li>
<li>
DeliveredToTerminal. </li>
<li>
DeliveryNotificationNotSupported. </li>
</ul>
</li>
</ul>
<p>For a more detailed description see the <a class="el" href="api_reference.html">API Reference</a>.</p>
<h3><a class="anchor" id="receiving_SMS_messages"></a>
Receiving SMS messages</h3>
<p>Your application can receive SMS from users sent to BlueVia shortcodes including your application keyword. You have to take into account that you will need to remember the SMS keyword you defined when you requested you API key. The function signature is:</p>
<div class="fragment"><pre class="fragment"> ArrayList&lt;ReceivedSms&gt; getMessages(String registrationId); 
</pre></div><p>For a more detailed description see the <a class="el" href="api_reference.html">API Reference</a>.</p>
<h3><a class="anchor" id="blv_sms_api_code_example"></a>
Bluevia SMS API: code example</h3>
<div class="fragment"><pre class="fragment"><span class="comment">//-----------------------------------------------</span>
<span class="comment">// Send an SMS</span>
<span class="comment">// 1. Create the client (you have to choose the mode (HTTP/Mock) and include the OAuth authorization values)</span>
Token accessToken = <span class="keyword">new</span> Token(<span class="stringliteral">&quot;oauth_token&quot;</span>, <span class="stringliteral">&quot;oauth_token_secret&quot;</span>);
   
BlueviaSmsClient smsClient = <span class="keyword">new</span> BlueviaSmsClient(getApplicationContext(), AbstractRestClient.Mode.HTTP, <span class="stringliteral">&quot;consumer_key&quot;</span>,<span class="stringliteral">&quot;consumer_secret&quot;</span>, accessToken); 

<span class="comment">// 2. Build the message</span>
<span class="comment">// The addresses are UserId Objects</span>
SmsMessage sms = <span class="keyword">new</span> SmsMessage();
sms.setMessage(<span class="stringliteral">&quot;This is the text to be sent&quot;</span>);
sms.addAddress(<span class="keyword">new</span> UserId(Type.PHONE_NUMBER,<span class="stringliteral">&quot;600010101&quot;</span>));
String result = null;

<span class="comment">// 3. Send the message.</span>
<span class="keywordflow">try</span> {
        result = smsClient.sendSms(sms);
<span class="comment">//-----------------------------------------------</span>

<span class="comment">//-----------------------------------------------</span>
<span class="comment">// 4. Retrieve the delivery status of the sent SMS.</span>
ArrayList&lt;MessageDeliveryStatus&gt; statusObj = smsClient.getSmsDeliveryStatus(result);
<span class="keywordflow">for</span> (MessageDeliveryStatus singleStatus : statusObj) {
        MessageDeliveryStatus.Status status = singleStatus.getStatus();

        <span class="keywordflow">switch</span> (status) {
        <span class="keywordflow">case</span> DELIVERED_TO_TERMINAL:
                Log.i (TAG, <span class="stringliteral">&quot;Delivered to terminal&quot;</span>);
                <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> DELIVERED_TO_NETWORK:
                Log.i (TAG, <span class="stringliteral">&quot;Delivered to network&quot;</span>);
                <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> DELIVERY_IMPOSSIBLE:
                Log.i (TAG, <span class="stringliteral">&quot;Delivery impossible&quot;</span>);
                <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> DELIVERY_NOTIFICATION_NOT_SUPPORTED:
                Log.i (TAG, <span class="stringliteral">&quot;Delivery notification not supported&quot;</span>);
                <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> DELIVERY_UNCERTAIN:
                Log.i (TAG, <span class="stringliteral">&quot;Delivery uncertain&quot;</span>);
                <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> MESSAGE_WAITING:
                Log.i (TAG, <span class="stringliteral">&quot;Message waiting&quot;</span>);
                <span class="keywordflow">break</span>;
        }
}
<span class="comment">//-----------------------------------------------</span>
} <span class="keywordflow">catch</span> (BlueviaClientException e) {
        Log.e (TAG,<span class="stringliteral">&quot;Error sending SMS&quot;</span>, e);
}

<span class="comment">//-----------------------------------------------</span>
<span class="comment">// Receiving SMSs:</span>
<span class="comment">// 6. Retrieve sent SMSs:</span>

ArrayList&lt;ReceivedSms&gt; list = smsClient.getMessages(<span class="stringliteral">&quot;553456&quot;</span>); 

<span class="keywordflow">for</span> (ReceivedSms sms : list){
        Log.i(TAG, <span class="stringliteral">&quot;Received sms: &quot;</span> + sms.getMessage()); 
}


<span class="comment">//-----------------------------------------------</span>
<span class="comment">// 7. Finally close the client</span>
smsClient.close();
</pre></div> </div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">Generated on Tue Nov 22 2011 15:13:47 for BlueViaAndroidSDK by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
